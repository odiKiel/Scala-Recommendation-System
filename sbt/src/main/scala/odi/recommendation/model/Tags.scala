package odi.recommendation
import scala.slick.driver.PostgresDriver.simple._
import Database.threadLocalSession

import net.liftweb.json._
import net.liftweb.json.Serialization.{read, write}
import net.liftweb.json.JsonDSL._
// Definition of the ITEMS table
case class Tag(id: Option[Int] = None, prefLabel: String) 

object Tags extends Table[Tag]("tags") with ModelTrait{
  def id = column[Int]("id", O.PrimaryKey, O.AutoInc) // This is the primary key column
  def prefLabel = column[String]("pref_label")
  def * = id.? ~ prefLabel <>(Tag, Tag.unapply _)
  def noID = prefLabel 

  def createTable = {
    db.withSession {
      Tags.ddl.create
    } 
  }

  def byPrefLabel(prefLabel: String): Tag = {
    var result: Option[Tag] = None;

    db withSession {
        // define the query and what we want as result
    	val query = for (i <-Tags if i.prefLabel === prefLabel) yield i.id ~ i.prefLabel 

    	// map the results to a Bid object
    	val inter = query mapResult {
    	  case(id, prefLabel) => Option(Tag(Option(id), prefLabel))
    	}

    	// check if there is one in the list and return it, or None otherwise
    	result = inter.list match {
    	  case _ :: tail => inter.first
    	  case Nil => None
    	}
    }
    //if result none create Tag
    if(result == None) {
      Tags.create(Tag(None, prefLabel))
    }
    else {
      result.get
    }


  }




  def all : List[Tag] = {
    db withSession {
      val q = Tags.map({u => u}).sortBy(_.id)
      q.list
    }
  }

  def create(tag: Tag): Tag = {
    var id: Int = -1;

    // start a db session
    db withSession {
      // create a new bid
      val res = Tags.noID insert (tag.prefLabel)
      // get the autogenerated bid
      val idQuery = Query(SimpleFunction.nullary[Int]("LASTVAL"))
      id = idQuery.list().head
    }
    // create a bid to return
    new Tag(Option(id), tag.prefLabel)
  }


  /**
   * Delete a bid
   */
  def delete(id: Int) = {

    //delete ratings and similaritems with this id
    ItemTags.deleteByTagId(id)

    val toDelete = Tags where (_.id === id)
    db withSession {
      toDelete.delete
    }
  }

  def deleteAll = {
    db withSession {
      val q = for { 
        t <- Tags 
      } yield t 

      q.mutate(_.delete) // deletes rows corresponding to query result 
    }
  }
}

