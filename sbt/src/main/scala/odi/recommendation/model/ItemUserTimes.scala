package odi.recommendation
import scala.slick.driver.PostgresDriver.simple._
import Database.threadLocalSession

import net.liftweb.json._
import net.liftweb.json.Serialization.{read, write}
import net.liftweb.json.JsonDSL._
// Definition of the ITEMS table
case class ItemUserTime(id: Option[Int] = None, itemId: Int, userId: Int, timeSpend: Double, timeScroll: Double) 

object ItemUserTimes extends Table[ItemUserTime]("item_user_times") with ModelTrait{
  def id = column[Int]("id", O.PrimaryKey, O.AutoInc) // This is the primary key column
  def itemId = column[Int]("item_id")
  def userId = column[Int]("user_id")
  def timeSpend = column[Double]("time_spend")
  def timeScroll = column[Double]("time_scroll")
  def * = id.? ~ itemId ~ userId ~ timeSpend ~ timeScroll<>(ItemUserTime, ItemUserTime.unapply _)
  def noID = itemId ~ userId ~ timeSpend ~ timeScroll 

  def createTable = {
    db.withSession {
      ItemUserTimes.ddl.create
    } 
  }

  def all : List[ItemUserTime] = {
    db withSession {
      val q = ItemUserTimes.map({u => u}).sortBy(_.id)
      q.list
    }
  }


  def create(itemUserTime: ItemUserTime): ItemUserTime = {
    var id: Int = -1;

    // start a db session
    db withSession {
    	val query = for (i <-ItemUserTimes if i.itemId === itemUserTime.itemId && i.userId === itemUserTime.userId) yield i.id ~ i.itemId ~ i.userId ~ i.timeSpend ~ i.timeScroll

    	val inter = query mapResult {
    	  case(id, itemId, userId, timeSpend, timeScroll) => Option(ItemUserTime(Option(id), itemId, userId, timeSpend, timeScroll))
    	}

      val result = inter.list match {
    	  case _ :: tail => inter.first
    	  case Nil => None
    	}
      println("result item user times create: "+result+"itemUserTime userId: "+itemUserTime.userId+" itemId: "+itemUserTime.itemId)
      if(result == None) {
        // create a new bid
        val res = ItemUserTimes.noID insert (itemUserTime.itemId, itemUserTime.userId, itemUserTime.timeSpend, itemUserTime.timeScroll)
        // get the autogenerated bid
        val idQuery = Query(SimpleFunction.nullary[Int]("LASTVAL"))
        id = idQuery.list().head
        new ItemUserTime(Option(id), itemUserTime.itemId, itemUserTime.userId, itemUserTime.timeSpend, itemUserTime.timeScroll)
      }
      else {
        val oldItemUserTime = result.get
        db withSession {
          val query = for (i <-ItemUserTimes if i.id === oldItemUserTime.id.get) yield i.id ~ i.itemId ~ i.userId ~ i.timeSpend ~ i.timeScroll
          query.update((oldItemUserTime.id.get, itemUserTime.itemId, itemUserTime.userId, (itemUserTime.timeSpend+oldItemUserTime.timeSpend), (itemUserTime.timeScroll+oldItemUserTime.timeScroll)))
        }
        new ItemUserTime(oldItemUserTime.id, itemUserTime.itemId, itemUserTime.userId, (itemUserTime.timeSpend+oldItemUserTime.timeSpend), (itemUserTime.timeScroll+oldItemUserTime.timeScroll))
      }
    }
    // create a bid to return
  }


  /**
   * Delete a bid
   */
  def delete(id: Int) = {

    val toDelete = ItemTags where (_.id === id)
    db withSession {
      toDelete.delete
    }

  }

  def deleteByTagId(tagId: Int) = {

    val toDelete = ItemTags where (_.tagId === tagId)
    db withSession {
      toDelete.delete
    }

  }


  def deleteAll = {
    db withSession {
      val q = for { 
        t <- ItemUserTimes 
      } yield t 

      q.mutate(_.delete) // deletes rows corresponding to query result 
    }
  }
}

