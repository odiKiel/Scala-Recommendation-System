package odi.recommendation
import scala.slick.driver.PostgresDriver.simple._
import Database.threadLocalSession

import net.liftweb.json._
import net.liftweb.json.Serialization.{read, write}
import net.liftweb.json.JsonDSL._
// Definition of the ITEMS table
case class ItemTag(id: Option[Int] = None, itemId: Int, tagId: Int) 

object ItemTags extends Table[ItemTag]("item_tags") with ModelTrait{
  def id = column[Int]("id", O.PrimaryKey, O.AutoInc) // This is the primary key column
  def itemId = column[Int]("item_id")
  def tagId = column[Int]("tag_id")
  def * = id.? ~ itemId ~ tagId <>(ItemTag, ItemTag.unapply _)
  def noID = itemId ~ tagId 

  def createTable = {
    db.withSession {
      ItemTags.ddl.create
    } 
  }

  def all : List[ItemTag] = {
    db withSession {
      val q = ItemTags.map({u => u}).sortBy(_.id)
      q.list
    }
  }

  def create(itemTag: ItemTag): ItemTag = {
    var id: Int = -1;

    // start a db session
    db withSession {
    	val query = for (i <-ItemTags if i.itemId === itemTag.itemId && i.tagId === itemTag.tagId) yield i.id ~ i.itemId ~ i.tagId

    	val inter = query mapResult {
    	  case(id, itemId, tagId) => Option(ItemTag(Option(id), itemId, tagId))
    	}

      val result = inter.list match {
    	  case _ :: tail => inter.first
    	  case Nil => None
    	}
      if(result == None) {
        // create a new bid
        val res = ItemTags.noID insert (itemTag.itemId, itemTag.tagId)
        // get the autogenerated bid
        val idQuery = Query(SimpleFunction.nullary[Int]("LASTVAL"))
        id = idQuery.list().head
        new ItemTag(Option(id), itemTag.itemId, itemTag.tagId)
      }
      else {
        result.get
      }
    }
    // create a bid to return
  }


  /**
   * Delete a bid
   */
  def delete(id: Int) = {

    val toDelete = ItemTags where (_.id === id)
    db withSession {
      toDelete.delete
    }

  }

  def deleteByTagId(tagId: Int) = {

    val toDelete = ItemTags where (_.tagId === tagId)
    db withSession {
      toDelete.delete
    }

  }

  def deleteByItemId(itemId: Int) = {

    val toDelete = ItemTags where (_.itemId === itemId)
    db withSession {
      toDelete.delete
    }

  }


  def deleteAll = {
    db withSession {
      val q = for { 
        t <- ItemTags 
      } yield t 

      q.mutate(_.delete) // deletes rows corresponding to query result 
    }
  }
}

